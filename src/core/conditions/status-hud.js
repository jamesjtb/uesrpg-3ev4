/**
 * src/core/conditions/status-hud.js
 *
 * Token HUD status ↔ system condition parity.
 *
 * Goals:
 * - Replace the default Token HUD status palette with the system's condition set.
 * - Ensure toggling from the Token HUD produces the same deterministic ActiveEffect-backed
 *   conditions as the rest of the system (i.e., correct AE changes + system flags).
 * Constraints:
 * - No ApplicationV2.
 * - No direct document mutation; use document update APIs.
 * - Avoid regressions: preserve CONFIG.specialStatusEffects entries (dead/defeated, etc.).
 */

import {
  // Core condition operations
  toggleCondition,
  hasCondition,
  setConditionValue,

  // Token HUD parity helpers
  getTokenHudStatusEffectConfigs,
  upgradeTokenHudStatusEffects,
  SYSTEM_TOKEN_HUD_STATUS_ID_SET
} from "./condition-engine.js";

import { applyFrenzied, removeFrenzied } from "./frenzied.js";

let _systemStatusEffectsRegistered = false;
let _statusHudInteropRegistered = false;

/**
 * Replace CONFIG.statusEffects to show system conditions on the Token HUD.
 *
 * We preserve any "special" status effects referenced by CONFIG.specialStatusEffects
 * (e.g. defeated/dead) to avoid breaking core behaviors.
 */
export function registerSystemStatusEffects() {
  if (_systemStatusEffectsRegistered) return;
  _systemStatusEffectsRegistered = true;
  const existing = Array.isArray(CONFIG.statusEffects) ? CONFIG.statusEffects : [];

  // Preserve special status effects by id (values are strings).
  const specialIds = new Set(
    Object.values(CONFIG.specialStatusEffects ?? {}).filter(v => typeof v === "string" && v.length)
  );

  /** @type {any[]} */
  const preserved = existing
    .filter(e => e && typeof e.id === "string" && specialIds.has(e.id))
    .map(e => ({ ...e, hud: true }));

  const systemEntries = getTokenHudStatusEffectConfigs();

  // Normalize a few icons to the intended core SVG assets.
  // This prevents regressions where earlier patches referenced legacy icon names.
  for (const e of systemEntries) {
    if (e?.id === "deafened") e.img = "icons/svg/deaf.svg";
  }

  // Merge preserved + system entries; system entries win.
  const byId = new Map();
  for (const e of preserved) byId.set(e.id, e);
  for (const e of systemEntries) byId.set(e.id, e);

  const excluded = new Set(["flying", "fly", "hover", "hovering", "burrow", "burrowing", "blind", "deaf"]);
  CONFIG.statusEffects = Array.from(byId.values()).filter(e => e && typeof e.id === "string" && !excluded.has(String(e.id).toLowerCase()));
}

/**
 * Register robust Token HUD interop.
 *
 * We use delegated (capture-phase) listeners on the .status-effects container.
 * This approach survives minor markup changes and prevents Foundry's default
 * toggle handler from running.
 */
export function registerStatusHudInterop() {
  if (_statusHudInteropRegistered) return;
  _statusHudInteropRegistered = true;
  if (!game.uesrpg) game.uesrpg = {};
  if (game.uesrpg._statusHudInteropV2) return;
  game.uesrpg._statusHudInteropV2 = true;

  // Proactively upgrade any previously-created "empty" core status effects which were
  // generated by the broken Package 13 build (missing changes/flags).
  Hooks.on("ready", () => {
    try {
      const actors = Array.from(game.actors ?? []);
      for (const actor of actors) {
        // Fire-and-forget; keep startup snappy.
        void upgradeTokenHudStatusEffects(actor);
      }
    } catch (err) {
      console.warn("UESRPG | Token HUD status effect upgrade sweep failed", err);
    }
  });

  Hooks.on("renderTokenHUD", (app, html) => {
    try {
      const token = _getTokenFromHud(app);
      const actor = token?.actor ?? null;
      if (!actor) return;

      const root = html?.[0] ?? html;
      if (!root) return;

      const container = root.querySelector?.(".status-effects") ?? null;
      if (!container) return;

      // Avoid rebinding across HUD rerenders.
      if (container.dataset?.uesrpgStatusDelegated === "1") return;
      container.dataset.uesrpgStatusDelegated = "1";
      // Intercept pointer/mouse input at capture phase to prevent Foundry's default toggle handler.
      // We handle:
      let lastHandled = { t: 0, id: null };

      const shouldSuppress = (id) => {
        const now = Date.now();
        return lastHandled.id === id && (now - lastHandled.t) < 250;
      };

      const markHandled = (id) => {
        lastHandled = { t: Date.now(), id };
      };

      const handleToggle = async (statusId) => {
        await _handleHudToggle(app, actor, statusId);
        lastHandled = { t: Date.now(), id: statusId };
      };

      const intercept = (ev, kind) => {
        const statusId = _getStatusIdFromEvent(ev, actor);
        if (!statusId) return;
        if (!SYSTEM_TOKEN_HUD_STATUS_ID_SET.has(statusId)) return;

        // Prevent default TokenHUD status toggling.
        ev.preventDefault();
        ev.stopPropagation();
        ev.stopImmediatePropagation();

        if (kind === 'primary') {
          void handleToggle(statusId);
        } else if (kind === 'secondary') {
          void handleToggle(statusId);
        }
      };

      // Pointerdown is earliest for modern browsers; also bind mousedown as a backstop.
      container.addEventListener('pointerdown', (ev) => {
        try {
          if (ev.button === 0) return intercept(ev, 'primary');
          if (ev.button === 2) return intercept(ev, 'secondary');
        } catch (err) {
          console.warn('UESRPG | Token HUD status pointerdown handler failed', err);
        }
      }, true);

      container.addEventListener('mousedown', (ev) => {
        try {
          if (ev.button === 0) return intercept(ev, 'primary');
          if (ev.button === 2) return intercept(ev, 'secondary');
        } catch (err) {
          console.warn('UESRPG | Token HUD status mousedown handler failed', err);
        }
      }, true);

      // Click is retained as a fallback (e.g., if a platform does not fire pointerdown).
      container.addEventListener('click', (ev) => {
        try {
          if (ev.button !== 0) return;
          const statusId = _getStatusIdFromEvent(ev, actor);
          if (!statusId) return;
          if (!SYSTEM_TOKEN_HUD_STATUS_ID_SET.has(statusId)) return;

          // If we already handled the corresponding pointer/mouse down, just suppress the default click.
          if (shouldSuppress(statusId)) {
            ev.preventDefault();
            ev.stopPropagation();
            ev.stopImmediatePropagation();
            return;
          }

          ev.preventDefault();
          ev.stopPropagation();
          ev.stopImmediatePropagation();

          void handleToggle(statusId);
        } catch (err) {
          console.warn('UESRPG | Token HUD status click handler failed', err);
        }
      }, true);
      // Suppress the context menu on system statuses to prevent core toggles from bypassing the condition engine.
      container.addEventListener('contextmenu', (ev) => {
        try {
          const statusId = _getStatusIdFromEvent(ev, actor);
          if (!statusId) return;
          if (!SYSTEM_TOKEN_HUD_STATUS_ID_SET.has(statusId)) return;
          ev.preventDefault();
          ev.stopPropagation();
          ev.stopImmediatePropagation();
        } catch (err) {
          console.warn('UESRPG | Token HUD status contextmenu handler failed', err);
        }
      }, true);

    } catch (err) {
      console.warn("UESRPG | renderTokenHUD interop failed", err);
    }
  });
}


function _normalizeHudStatusId(raw) {
  let s = String(raw || "").trim().toLowerCase();
  if (!s) return null;
  // Strip numeric suffixes from names/ids, if present.
  s = s.replace(/\s*\(\s*\d+\s*\)\s*$/, "").trim();
  // Normalize common core ↔ system naming differences.
  if (s === "blind") s = "blinded";
  if (s === "deaf") s = "deafened";
  return s;
}

function _getTokenFromHud(app) {
  // TokenHUD (Application) stores the Token placeable on .object.
  return app?.object ?? app?.token ?? null;
}

function _getStatusIdFromEvent(ev, actor) {
  const t = ev?.target;
  if (!t || typeof t.closest !== "function") return null;

  // In v13 TokenHUD, status icons may be rendered with data-status-id (palette entry),
  // or data-effect-id (active effect instance).
  const el = t.closest("[data-status-id],[data-effect-id]") ?? null;
  if (!el) return null;

  const statusId = el.dataset?.statusId ?? null;
  if (statusId) return _normalizeHudStatusId(statusId);

  const effectId = el.dataset?.effectId ?? null;
  if (!effectId || !actor?.effects) return null;

  const effect = actor.effects.get(String(effectId)) ?? null;
  if (!effect) return null;

  // Prefer the system's condition key lane.
  const sysKey = effect?.flags?.["uesrpg-3ev4"]?.condition?.key ?? null;
  if (sysKey) return _normalizeHudStatusId(sysKey);

  // Next: core statusId.
  const coreId = effect?.flags?.core?.statusId ?? null;
  if (coreId) return _normalizeHudStatusId(coreId);

  // Next: effect.statuses (Set of ids).
  try {
    const statuses = effect?.statuses ? Array.from(effect.statuses) : [];
    for (const s of statuses) {
      const id = _normalizeHudStatusId(s);
      if (SYSTEM_TOKEN_HUD_STATUS_ID_SET.has(id)) return id;
    }
  } catch (_e) {}

  // Fallback: try to match by localized name.
  const name = _normalizeHudStatusId(effect?.name ?? "");
  for (const id of SYSTEM_TOKEN_HUD_STATUS_ID_SET) {
    if (name === id) return id;
  }
  return null;
}

async function _handleHudToggle(app, actor, statusId) {
  if (!actor) return;

  // X-value conditions: toggle at value 1.
  if (statusId === "bleeding" || statusId === "burning") {
    const active = hasCondition(actor, statusId);
    if (active) {
      await setConditionValue(actor, statusId, 0);
    } else {
      await setConditionValue(actor, statusId, 1);
    }
  } else if (statusId === "frenzied") {
    // Frenzied: requires custom application for talent-based dynamic changes
    const active = hasCondition(actor, statusId);
    if (active) {
      await removeFrenzied(actor, { applySPLoss: false }); // No SP loss on manual toggle
    } else {
      await applyFrenzied(actor, { source: "Token HUD", voluntary: true });
    }
  } else {
    // Static conditions: toggle via the condition engine for canonical AE wiring.
    await toggleCondition(actor, statusId, { origin: null, source: "Token HUD" });
  }

  try {
    app.render();
  } catch (_err) {
    // ignore
  }
}
